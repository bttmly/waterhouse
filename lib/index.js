// Generated by CoffeeScript 1.8.0
var FuncCtor, codeToEval, ctx, eff, funcProto, i, isOtherFunc, isRegFunc, key, makeArgString, makeWrapperCode, val, vm, waterhouse, wrap, wrapToLength, wrappers, _fn, _i;

vm = require("vm");

eff = require("eff");

makeArgString = function(n) {
  var args, num, _i, _ref;
  if (n === 0) {
    return "";
  }
  args = [];
  for (num = _i = 0, _ref = n - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; num = 0 <= _ref ? ++_i : --_i) {
    args.push(String.fromCharCode(num % 26 + 97));
  }
  return args.join(", ");
};

makeWrapperCode = function(n) {
  var args;
  args = makeArgString(n);
  return "var wrap" + (String(n).toUpperCase()) + " = function (fn) { return function (" + args + ") { return fn.apply(this, arguments); }; };";
};

codeToEval = "";

for (i = _i = 0; _i <= 10; i = ++_i) {
  codeToEval += makeWrapperCode(i);
}

codeToEval += "var funcProto = Function.prototype;";

codeToEval += "var FuncCtor = Function;";

ctx = vm.createContext();

vm.runInContext(codeToEval, ctx);

funcProto = ctx.funcProto;

FuncCtor = ctx.FuncCtor;

wrappers = (function() {
  var _j, _results;
  _results = [];
  for (i = _j = 0; _j <= 10; i = ++_j) {
    _results.push(ctx["wrap" + i]);
  }
  return _results;
})();

isOtherFunc = function(fn) {
  return typeof fn === "function" && fn instanceof FuncCtor;
};

isRegFunc = function(fn) {
  return typeof fn === "function" && fn instanceof Function;
};

wrap = function(fn) {
  if (!wrappers[fn.length]) {
    throw new RangeError("That function takes too many damn arguments");
  }
  return wrappers[fn.length](fn);
};

wrapToLength = function(len, fn) {
  if (!wrappers[len]) {
    throw new RangeError("That length isn't gonna work");
  }
  return wrappers[len](fn);
};

waterhouse = function(fn) {
  var wrapped;
  wrapped = wrap(fn);
  return wrapToLength(fn.length, function() {
    var ret;
    ret = wrapped.apply(this, arguments);
    if (isRegFunc(ret)) {
      return wrap(ret);
    } else {
      return ret;
    }
  });
};

waterhouse.extend = function(methods) {
  var key, val, _fn;
  _fn = function(key, val) {
    return funcProto[key] = isRegFunc(val) ? wrap(val) : val;
  };
  for (key in methods) {
    val = methods[key];
    _fn(key, val);
  }
};

waterhouse.funcProto = funcProto;

waterhouse.FuncCtor = FuncCtor;

_fn = function(key, val) {
  return funcProto[key] = function() {
    var arg, args, _j, _len;
    args = new Array(arguments.length + 1);
    args[0] = this;
    for (i = _j = 0, _len = arguments.length; _j < _len; i = ++_j) {
      arg = arguments[i];
      args[i + 1] = arg;
    }
    return val.apply(null, args);
  };
};
for (key in eff) {
  val = eff[key];
  _fn(key, val);
}

console.log(Object.keys(wrappers));

module.exports = waterhouse;
